// Generated by LiveScript 1.5.0
/**
 * User: Roy
 * Date: 2016/9/19
 * Time: 10:10
 */
var nats, exp, outExp;
nats = require('nats');
exp = function(natsServers, selfName, connectCb){
  var _self;
  _self = this;
  this.defaultRpcTimeout = 1000 * 30;
  this.natsServers = natsServers;
  this.subsQuery = {};
  this.subsFull = {};
  this.subsPartial = {};
  this.subsPartialNamed = {};
  this.subsPushFull = {};
  this.subsPushPartial = {};
  this.subsPushPartialNamed = {};
  this.client = nats.connect({
    reconnect: true,
    reconnectTimeWait: 1000 * 2,
    maxReconnectAttempts: 30 * 60 * 24 * 30 * 12 * 10,
    servers: natsServers
  });
  this.requestsSeq = 0;
  this.requestsCbs = {};
  this.replySubString = "Reply." + selfName + ".";
  this.replyQuerySubString = "ReplyQ." + selfName + ".";
  this.replySub = _self.client.subscribe(_self.replySubString + ">", function(msg, reply, subject){
    var _subject, _topicTokens, seq, cb;
    _subject = subject;
    _topicTokens = _subject.split(".");
    if (_topicTokens.length < 1) {
      return;
    }
    seq = _topicTokens[_topicTokens.length - 1];
    msg = _self.parseJson(msg);
    if (_self.requestsCbs[seq]) {
      cb = _self.requestsCbs[seq].cb;
      clearTimeout(_self.requestsCbs[seq].timer);
      delete _self.requestsCbs[seq];
      cb(null, msg);
    }
  });
  _self.inited = false;
  if (connectCb) {
    _self.client.once('connect', function(){
      if (!_self.inited) {
        _self.inited = true;
        connectCb();
      }
    });
    _self.client.once('reconnect', function(){
      if (!_self.inited) {
        _self.inited = true;
        connectCb();
      }
    });
  }
};
exp.prototype.SetDefaultRpcTimeout = function(timeout){
  var _self;
  _self = this;
  if (timeout < 1000 * 1) {
    return _self.defaultRpcTimeout = 1000;
  } else {
    return _self.defaultRpcTimeout = timeout;
  }
};
exp.prototype.parseJson = function(msg){
  var retMsg;
  retMsg = msg;
  if (typeof msg === 'string' && (msg[0] = '{')) {
    try {
      retMsg = JSON.parse(msg);
      if (retMsg && retMsg.type === 'Buffer') {
        retMsg = new Buffer(retMsg.data);
      }
    } catch (e$) {}
  }
  return retMsg;
};
exp.prototype.publishRaw = function(to, msg){
  var _self, str;
  _self = this;
  if (typeof msg === 'object') {
    str = JSON.stringify(msg);
    return _self.client.publish(to, str);
  } else {
    return _self.client.publish(to, msg);
  }
};
exp.prototype.publishRawWithReply = function(to, msg, reply){
  var _self, str;
  _self = this;
  if (typeof msg === 'object') {
    str = JSON.stringify(msg);
    return _self.client.publish(to, str, reply);
  } else {
    return _self.client.publish(to, msg, reply);
  }
};
exp.prototype.RegisterQueryCallback = function(topic, handler){
  var _self, _topic;
  _self = this;
  if (topic.length <= 0) {
    return;
  }
  _topic = _self.replyQuerySubString + topic;
  if (_self.subsQuery[_topic]) {
    _self.client.unsubscribe(_self.subsQuery[_topic]);
    delete _self.subsQuery[_topic];
  }
  _self.subsQuery[_topic] = _self.client.subscribe(_topic, function(msg, reply, subject){
    msg = _self.parseJson(msg);
    handler(subject, msg);
  });
};
exp.prototype.UnRegisterQueryCallbackAll = function(){
  var _self, k, ref$, v;
  _self = this;
  for (k in ref$ = _self.subsQuery) {
    v = ref$[k];
    _self.client.unsubscribe(v);
  }
  _self.subsQuery = {};
};
exp.prototype.RegisterHookRpcHandlerFull = function(topic, handler){
  var _self;
  _self = this;
  if (_self.subsFull[topic]) {
    _self.client.unsubscribe(_self.subsFull[topic]);
    delete _self.subsFull[topic];
  }
  _self.subsFull[topic] = _self.client.subscribe(topic, function(msg, reply, subject){
    msg = _self.parseJson(msg);
    handler(subject, msg);
  });
};
exp.prototype.RegisterHookReplyHandlerFull = function(topic, handler){
  var _self;
  _self = this;
  topic = "Reply.*." + topic + ".>";
  if (_self.subsFull[topic]) {
    _self.client.unsubscribe(_self.subsFull[topic]);
    delete _self.subsFull[topic];
  }
  _self.subsFull[topic] = _self.client.subscribe(topic, function(msg, reply, subject){
    msg = _self.parseJson(msg);
    handler(subject, msg);
  });
};
exp.prototype.RegisterRpcHandlerFull = function(topic, handler){
  var _self;
  _self = this;
  if (_self.subsFull[topic]) {
    _self.client.unsubscribe(_self.subsFull[topic]);
    delete _self.subsFull[topic];
  }
  _self.subsFull[topic] = _self.client.subscribe(topic, function(msg, reply, subject){
    var e;
    msg = _self.parseJson(msg);
    try {
      handler(subject, msg, function(err, result){
        if (typeof reply == 'string' && reply.length > 0) {
          if (err) {
            _self.publishRaw(reply, err);
          } else {
            _self.publishRaw(reply, result);
          }
        } else {
          console.error("[rpc] RegisterRpcHandlerFull reply error = ", reply);
        }
      });
    } catch (e$) {
      e = e$;
      console.error("[rpc] RegisterRpcHandlerFull Exception = ", e);
      _self.publishRaw(reply, {
        code: 500,
        err_string: "Server Exception"
      });
    }
  });
};
exp.prototype.RegisterRpcHandlerPartial = function(topic, handler){
  var _self;
  _self = this;
  if (_self.subsPartial[topic]) {
    _self.client.unsubscribe(_self.subsPartial[topic]);
    delete _self.subsPartial[topic];
  }
  _self.subsPartial[topic] = _self.client.subscribe(topic, {
    queue: 'default'
  }, function(msg, reply, subject){
    var e;
    msg = _self.parseJson(msg);
    try {
      handler(subject, msg, function(err, result){
        if (typeof reply == 'string' && reply.length > 0) {
          if (err) {
            _self.publishRaw(reply, err);
          } else {
            _self.publishRaw(reply, result);
          }
        } else {
          console.error("[rpc] RegisterRpcHandlerPartial reply error = ", reply);
        }
      });
    } catch (e$) {
      e = e$;
      console.error("[rpc] RegisterRpcHandlerPartial Exception = ", e);
      _self.publishRaw(reply, {
        code: 500,
        err_string: "Server Exception"
      });
    }
  });
};
exp.prototype.RegisterRpcHandlerPartialNamed = function(topic, partialNamed, handler){
  var _self;
  _self = this;
  if (_self.subsPartialNamed[topic]) {
    _self.client.unsubscribe(_self.subsPartialNamed[topic]);
    delete _self.subsPartialNamed[topic];
  }
  _self.subsPartialNamed[topic] = _self.client.subscribe(topic, {
    queue: partialNamed
  }, function(msg, reply, subject){
    var e;
    msg = _self.parseJson(msg);
    try {
      handler(subject, msg, function(err, result){
        if (typeof reply == 'string' && reply.length > 0) {
          if (err) {
            _self.publishRaw(reply, err);
          } else {
            _self.publishRaw(reply, result);
          }
        } else {
          console.error("[rpc] RegisterRpcHandlerPartialNamed reply error = ", reply);
        }
      });
    } catch (e$) {
      e = e$;
      console.error("[rpc] RegisterRpcHandlerPartialNamed Exception = ", e);
      _self.publishRaw(reply, {
        code: 500,
        err_string: "Server Exception"
      });
    }
  });
};
exp.prototype.UnRegisterRpcHandlerFull = function(topic){
  var _self;
  _self = this;
  if (_self.subsFull[topic]) {
    _self.client.unsubscribe(_self.subsFull[topic]);
    delete _self.subsFull[topic];
  }
};
exp.prototype.UnRegisterRpcHandlerPartial = function(topic){
  var _self;
  _self = this;
  if (_self.subsPartial[topic]) {
    _self.client.unsubscribe(_self.subsPartial[topic]);
    delete _self.subsPartial[topic];
  }
};
exp.prototype.UnRegisterRpcHandlerPartialNamed = function(topic){
  var _self;
  _self = this;
  if (_self.subsPartialNamed[topic]) {
    _self.client.unsubscribe(_self.subsPartialNamed[topic]);
    delete _self.subsPartialNamed[topic];
  }
};
exp.prototype.UnRegisterRpcHandlerAll = function(){
  var _self, k, ref$, v;
  _self = this;
  for (k in ref$ = _self.subsFull) {
    v = ref$[k];
    _self.client.unsubscribe(v);
  }
  for (k in ref$ = _self.subsPartial) {
    v = ref$[k];
    _self.client.unsubscribe(v);
  }
  for (k in ref$ = _self.subsPartialNamed) {
    v = ref$[k];
    _self.client.unsubscribe(v);
  }
  _self.subsFull = {};
  _self.subsPartial = {};
  _self.subsPartialNamed = {};
};
exp.prototype.RegisterPushHandlerFull = function(topic, handler){
  var _self;
  _self = this;
  if (_self.subsPushFull[topic]) {
    _self.client.unsubscribe(_self.subsPushFull[topic]);
    delete _self.subsPushFull[topic];
  }
  _self.subsPushFull[topic] = _self.client.subscribe(topic, function(msg, reply, subject){
    msg = _self.parseJson(msg);
    handler(subject, msg);
  });
};
exp.prototype.RegisterPushHandlerPartial = function(topic, handler){
  var _self;
  _self = this;
  if (_self.subsPushPartial[topic]) {
    _self.client.unsubscribe(_self.subsPushPartial[topic]);
    delete _self.subsPushPartial[topic];
  }
  _self.subsPushPartial[topic] = _self.client.subscribe(topic, {
    queue: 'default'
  }, function(msg, reply, subject){
    msg = _self.parseJson(msg);
    handler(subject, msg);
  });
};
exp.prototype.RegisterPushHandlerPartialNamed = function(topic, partialNamed, handler){
  var _self;
  _self = this;
  if (_self.subsPushPartialNamed[topic]) {
    _self.client.unsubscribe(_self.subsPushPartialNamed[topic]);
    delete _self.subsPushPartialNamed[topic];
  }
  _self.subsPushPartialNamed[topic] = _self.client.subscribe(topic, {
    queue: partialNamed
  }, function(msg, reply, subject){
    msg = _self.parseJson(msg);
    handler(subject, msg);
  });
};
exp.prototype.UnRegisterPushHandlerFull = function(topic){
  var _self;
  _self = this;
  if (_self.subsPushFull[topic]) {
    _self.client.unsubscribe(_self.subsPushFull[topic]);
    delete _self.subsPushFull[topic];
  }
};
exp.prototype.UnRegisterPushHandlerPartial = function(topic){
  var _self;
  _self = this;
  if (_self.subsPushPartial[topic]) {
    _self.client.unsubscribe(_self.subsPushPartial[topic]);
    delete _self.subsPushPartial[topic];
  }
};
exp.prototype.UnRegisterPushHandlerPartialNamed = function(topic){
  var _self;
  _self = this;
  if (_self.subsPushPartialNamed[topic]) {
    _self.client.unsubscribe(_self.subsPushPartialNamed[topic]);
    delete _self.subsPushPartialNamed[topic];
  }
};
exp.prototype.UnRegisterPushHandlerAll = function(){
  var _self, k, ref$, v;
  _self = this;
  for (k in ref$ = _self.subsPushFull) {
    v = ref$[k];
    _self.client.unsubscribe(v);
  }
  for (k in ref$ = _self.subsPushPartial) {
    v = ref$[k];
    _self.client.unsubscribe(v);
  }
  for (k in ref$ = _self.subsPushPartialNamed) {
    v = ref$[k];
    _self.client.unsubscribe(v);
  }
  _self.subsPushFull = {};
  _self.subsPushPartial = {};
  _self.subsPushPartialNamed = {};
};
exp.prototype.Query = function(topic, msg){
  var _self, replyString;
  _self = this;
  replyString = _self.replyQuerySubString + topic;
  console.log("Query topic = ", topic);
  console.log("Query replyString = ", replyString);
  _self.publishRawWithReply(topic, msg, replyString);
};
exp.prototype.Push = function(topic, msg){
  var _self;
  _self = this;
  return _self.publishRaw(topic, msg);
};
exp.prototype.RpcAsync = function(topic, msg, callback){
  var _self;
  _self = this;
  _self.RpcAsyncTimeout(topic, msg, _self.defaultRpcTimeout, callback);
};
exp.prototype.RpcAsyncTimeout = function(topic, msg, timeout, callback){
  var _self, seq, replyString, timer;
  _self = this;
  _self.requestsSeq++;
  seq = "" + _self.requestsSeq;
  replyString = _self.replySubString + topic + "." + seq;
  timer = setTimeout(function(){
    if (_self.requestsCbs[seq]) {
      delete _self.requestsCbs[seq];
    }
    callback(new Error("RPC Timeout:" + timeout + "ms"));
  }, timeout);
  _self.requestsCbs[seq] = {
    seq: seq,
    timer: timer,
    cb: callback
  };
  _self.publishRawWithReply(topic, msg, replyString);
};
exp.prototype.Close = function(){
  var _self;
  _self = this;
  _self.UnRegisterRpcHandlerAll();
  _self.UnRegisterPushHandlerAll();
  _self.UnRegisterQueryCallbackAll();
  _self.client.close();
};
outExp = function(){};
outExp.prototype.Create = function(natsServers, selfName, connectCb){
  return new exp(natsServers, selfName, connectCb);
};
module.exports = outExp;